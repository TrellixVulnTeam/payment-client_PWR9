/**
 * @fileoverview gRPC-Web generated client stub for mcuc.stark.ultron
 * @enhanceable
 * @public
 */

// GENERATED CODE -- DO NOT EDIT!


/* eslint-disable */
// @ts-nocheck


import * as grpcWeb from 'grpc-web';

import * as stark_api_ultron_pb from './ultron_pb';


export class UltronClient {
  client_: grpcWeb.AbstractClientBase;
  hostname_: string;
  credentials_: null | { [index: string]: string; };
  options_: null | { [index: string]: any; };

  constructor (hostname: string,
               credentials?: null | { [index: string]: string; },
               options?: null | { [index: string]: any; }) {
    if (!options) options = {};
    if (!credentials) credentials = {};
    options['format'] = 'text';

    this.client_ = new grpcWeb.GrpcWebClientBase(options);
    this.hostname_ = hostname;
    this.credentials_ = credentials;
    this.options_ = options;
  }

  methodInfoCreateCryptoWithdraw = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.CreateCryptoWithdrawReply,
    (request: stark_api_ultron_pb.CreateCryptoWithdrawRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.CreateCryptoWithdrawReply.deserializeBinary
  );

  createCryptoWithdraw(
    request: stark_api_ultron_pb.CreateCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.CreateCryptoWithdrawReply>;

  createCryptoWithdraw(
    request: stark_api_ultron_pb.CreateCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.CreateCryptoWithdrawReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.CreateCryptoWithdrawReply>;

  createCryptoWithdraw(
    request: stark_api_ultron_pb.CreateCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.CreateCryptoWithdrawReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/CreateCryptoWithdraw',
        request,
        metadata || {},
        this.methodInfoCreateCryptoWithdraw,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/CreateCryptoWithdraw',
    request,
    metadata || {},
    this.methodInfoCreateCryptoWithdraw);
  }

  methodInfoCancelCryptoWithdraw = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.CancelCryptoWithdrawReply,
    (request: stark_api_ultron_pb.CancelCryptoWithdrawRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.CancelCryptoWithdrawReply.deserializeBinary
  );

  cancelCryptoWithdraw(
    request: stark_api_ultron_pb.CancelCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.CancelCryptoWithdrawReply>;

  cancelCryptoWithdraw(
    request: stark_api_ultron_pb.CancelCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.CancelCryptoWithdrawReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.CancelCryptoWithdrawReply>;

  cancelCryptoWithdraw(
    request: stark_api_ultron_pb.CancelCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.CancelCryptoWithdrawReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/CancelCryptoWithdraw',
        request,
        metadata || {},
        this.methodInfoCancelCryptoWithdraw,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/CancelCryptoWithdraw',
    request,
    metadata || {},
    this.methodInfoCancelCryptoWithdraw);
  }

  methodInfoApproveCryptoWithdraw = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.ApproveCryptoWithdrawReply,
    (request: stark_api_ultron_pb.ApproveCryptoWithdrawRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.ApproveCryptoWithdrawReply.deserializeBinary
  );

  approveCryptoWithdraw(
    request: stark_api_ultron_pb.ApproveCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.ApproveCryptoWithdrawReply>;

  approveCryptoWithdraw(
    request: stark_api_ultron_pb.ApproveCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ApproveCryptoWithdrawReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.ApproveCryptoWithdrawReply>;

  approveCryptoWithdraw(
    request: stark_api_ultron_pb.ApproveCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ApproveCryptoWithdrawReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/ApproveCryptoWithdraw',
        request,
        metadata || {},
        this.methodInfoApproveCryptoWithdraw,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/ApproveCryptoWithdraw',
    request,
    metadata || {},
    this.methodInfoApproveCryptoWithdraw);
  }

  methodInfoSubmitCryptoWithdraw = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.SubmitCryptoWithdrawReply,
    (request: stark_api_ultron_pb.SubmitCryptoWithdrawRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.SubmitCryptoWithdrawReply.deserializeBinary
  );

  submitCryptoWithdraw(
    request: stark_api_ultron_pb.SubmitCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.SubmitCryptoWithdrawReply>;

  submitCryptoWithdraw(
    request: stark_api_ultron_pb.SubmitCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.SubmitCryptoWithdrawReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.SubmitCryptoWithdrawReply>;

  submitCryptoWithdraw(
    request: stark_api_ultron_pb.SubmitCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.SubmitCryptoWithdrawReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/SubmitCryptoWithdraw',
        request,
        metadata || {},
        this.methodInfoSubmitCryptoWithdraw,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/SubmitCryptoWithdraw',
    request,
    metadata || {},
    this.methodInfoSubmitCryptoWithdraw);
  }

  methodInfoRejectCryptoWithdraw = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.RejectCryptoWithdrawReply,
    (request: stark_api_ultron_pb.RejectCryptoWithdrawRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.RejectCryptoWithdrawReply.deserializeBinary
  );

  rejectCryptoWithdraw(
    request: stark_api_ultron_pb.RejectCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.RejectCryptoWithdrawReply>;

  rejectCryptoWithdraw(
    request: stark_api_ultron_pb.RejectCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.RejectCryptoWithdrawReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.RejectCryptoWithdrawReply>;

  rejectCryptoWithdraw(
    request: stark_api_ultron_pb.RejectCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.RejectCryptoWithdrawReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/RejectCryptoWithdraw',
        request,
        metadata || {},
        this.methodInfoRejectCryptoWithdraw,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/RejectCryptoWithdraw',
    request,
    metadata || {},
    this.methodInfoRejectCryptoWithdraw);
  }

  methodInfoCancelCryptoTopUp = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.CancelCryptoTopUpReply,
    (request: stark_api_ultron_pb.CancelCryptoTopUpRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.CancelCryptoTopUpReply.deserializeBinary
  );

  cancelCryptoTopUp(
    request: stark_api_ultron_pb.CancelCryptoTopUpRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.CancelCryptoTopUpReply>;

  cancelCryptoTopUp(
    request: stark_api_ultron_pb.CancelCryptoTopUpRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.CancelCryptoTopUpReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.CancelCryptoTopUpReply>;

  cancelCryptoTopUp(
    request: stark_api_ultron_pb.CancelCryptoTopUpRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.CancelCryptoTopUpReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/CancelCryptoTopUp',
        request,
        metadata || {},
        this.methodInfoCancelCryptoTopUp,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/CancelCryptoTopUp',
    request,
    metadata || {},
    this.methodInfoCancelCryptoTopUp);
  }

  methodInfoApproveCryptoTopUp = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.ApproveCryptoTopUpReply,
    (request: stark_api_ultron_pb.ApproveCryptoTopUpRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.ApproveCryptoTopUpReply.deserializeBinary
  );

  approveCryptoTopUp(
    request: stark_api_ultron_pb.ApproveCryptoTopUpRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.ApproveCryptoTopUpReply>;

  approveCryptoTopUp(
    request: stark_api_ultron_pb.ApproveCryptoTopUpRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ApproveCryptoTopUpReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.ApproveCryptoTopUpReply>;

  approveCryptoTopUp(
    request: stark_api_ultron_pb.ApproveCryptoTopUpRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ApproveCryptoTopUpReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/ApproveCryptoTopUp',
        request,
        metadata || {},
        this.methodInfoApproveCryptoTopUp,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/ApproveCryptoTopUp',
    request,
    metadata || {},
    this.methodInfoApproveCryptoTopUp);
  }

  methodInfoRejectCryptoTopUp = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.RejectCryptoTopUpReply,
    (request: stark_api_ultron_pb.RejectCryptoTopUpRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.RejectCryptoTopUpReply.deserializeBinary
  );

  rejectCryptoTopUp(
    request: stark_api_ultron_pb.RejectCryptoTopUpRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.RejectCryptoTopUpReply>;

  rejectCryptoTopUp(
    request: stark_api_ultron_pb.RejectCryptoTopUpRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.RejectCryptoTopUpReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.RejectCryptoTopUpReply>;

  rejectCryptoTopUp(
    request: stark_api_ultron_pb.RejectCryptoTopUpRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.RejectCryptoTopUpReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/RejectCryptoTopUp',
        request,
        metadata || {},
        this.methodInfoRejectCryptoTopUp,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/RejectCryptoTopUp',
    request,
    metadata || {},
    this.methodInfoRejectCryptoTopUp);
  }

  methodInfoGetCryptoWallet = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.GetCryptoWalletReply,
    (request: stark_api_ultron_pb.GetCryptoWalletRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.GetCryptoWalletReply.deserializeBinary
  );

  getCryptoWallet(
    request: stark_api_ultron_pb.GetCryptoWalletRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.GetCryptoWalletReply>;

  getCryptoWallet(
    request: stark_api_ultron_pb.GetCryptoWalletRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.GetCryptoWalletReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.GetCryptoWalletReply>;

  getCryptoWallet(
    request: stark_api_ultron_pb.GetCryptoWalletRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.GetCryptoWalletReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/GetCryptoWallet',
        request,
        metadata || {},
        this.methodInfoGetCryptoWallet,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/GetCryptoWallet',
    request,
    metadata || {},
    this.methodInfoGetCryptoWallet);
  }

  methodInfoValidateCryptoWallets = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.ValidateCryptoWalletsReply,
    (request: stark_api_ultron_pb.ValidateCryptoWalletsRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.ValidateCryptoWalletsReply.deserializeBinary
  );

  validateCryptoWallets(
    request: stark_api_ultron_pb.ValidateCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.ValidateCryptoWalletsReply>;

  validateCryptoWallets(
    request: stark_api_ultron_pb.ValidateCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ValidateCryptoWalletsReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.ValidateCryptoWalletsReply>;

  validateCryptoWallets(
    request: stark_api_ultron_pb.ValidateCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ValidateCryptoWalletsReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/ValidateCryptoWallets',
        request,
        metadata || {},
        this.methodInfoValidateCryptoWallets,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/ValidateCryptoWallets',
    request,
    metadata || {},
    this.methodInfoValidateCryptoWallets);
  }

  methodInfoImportCryptoWallets = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.ImportCryptoWalletsReply,
    (request: stark_api_ultron_pb.ImportCryptoWalletsRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.ImportCryptoWalletsReply.deserializeBinary
  );

  importCryptoWallets(
    request: stark_api_ultron_pb.ImportCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.ImportCryptoWalletsReply>;

  importCryptoWallets(
    request: stark_api_ultron_pb.ImportCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ImportCryptoWalletsReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.ImportCryptoWalletsReply>;

  importCryptoWallets(
    request: stark_api_ultron_pb.ImportCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ImportCryptoWalletsReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/ImportCryptoWallets',
        request,
        metadata || {},
        this.methodInfoImportCryptoWallets,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/ImportCryptoWallets',
    request,
    metadata || {},
    this.methodInfoImportCryptoWallets);
  }

  methodInfoListCryptoWallets = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.ListCryptoWalletsReply,
    (request: stark_api_ultron_pb.ListCryptoWalletsRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.ListCryptoWalletsReply.deserializeBinary
  );

  listCryptoWallets(
    request: stark_api_ultron_pb.ListCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.ListCryptoWalletsReply>;

  listCryptoWallets(
    request: stark_api_ultron_pb.ListCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ListCryptoWalletsReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.ListCryptoWalletsReply>;

  listCryptoWallets(
    request: stark_api_ultron_pb.ListCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ListCryptoWalletsReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/ListCryptoWallets',
        request,
        metadata || {},
        this.methodInfoListCryptoWallets,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/ListCryptoWallets',
    request,
    metadata || {},
    this.methodInfoListCryptoWallets);
  }

  methodInfoValidateCryptoHotWallets = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.ValidateCryptoHotWalletsReply,
    (request: stark_api_ultron_pb.ValidateCryptoHotWalletsRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.ValidateCryptoHotWalletsReply.deserializeBinary
  );

  validateCryptoHotWallets(
    request: stark_api_ultron_pb.ValidateCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.ValidateCryptoHotWalletsReply>;

  validateCryptoHotWallets(
    request: stark_api_ultron_pb.ValidateCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ValidateCryptoHotWalletsReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.ValidateCryptoHotWalletsReply>;

  validateCryptoHotWallets(
    request: stark_api_ultron_pb.ValidateCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ValidateCryptoHotWalletsReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/ValidateCryptoHotWallets',
        request,
        metadata || {},
        this.methodInfoValidateCryptoHotWallets,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/ValidateCryptoHotWallets',
    request,
    metadata || {},
    this.methodInfoValidateCryptoHotWallets);
  }

  methodInfoImportCryptoHotWallets = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.ImportCryptoHotWalletsReply,
    (request: stark_api_ultron_pb.ImportCryptoHotWalletsRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.ImportCryptoHotWalletsReply.deserializeBinary
  );

  importCryptoHotWallets(
    request: stark_api_ultron_pb.ImportCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.ImportCryptoHotWalletsReply>;

  importCryptoHotWallets(
    request: stark_api_ultron_pb.ImportCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ImportCryptoHotWalletsReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.ImportCryptoHotWalletsReply>;

  importCryptoHotWallets(
    request: stark_api_ultron_pb.ImportCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ImportCryptoHotWalletsReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/ImportCryptoHotWallets',
        request,
        metadata || {},
        this.methodInfoImportCryptoHotWallets,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/ImportCryptoHotWallets',
    request,
    metadata || {},
    this.methodInfoImportCryptoHotWallets);
  }

  methodInfoListCryptoHotWallets = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.ListCryptoHotWalletsReply,
    (request: stark_api_ultron_pb.ListCryptoHotWalletsRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.ListCryptoHotWalletsReply.deserializeBinary
  );

  listCryptoHotWallets(
    request: stark_api_ultron_pb.ListCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.ListCryptoHotWalletsReply>;

  listCryptoHotWallets(
    request: stark_api_ultron_pb.ListCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ListCryptoHotWalletsReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.ListCryptoHotWalletsReply>;

  listCryptoHotWallets(
    request: stark_api_ultron_pb.ListCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.ListCryptoHotWalletsReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/ListCryptoHotWallets',
        request,
        metadata || {},
        this.methodInfoListCryptoHotWallets,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/ListCryptoHotWallets',
    request,
    metadata || {},
    this.methodInfoListCryptoHotWallets);
  }

  methodInfoGetSystemCryptoHotWallets = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.GetSystemCryptoHotWalletsReply,
    (request: stark_api_ultron_pb.GetSystemCryptoHotWalletsRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.GetSystemCryptoHotWalletsReply.deserializeBinary
  );

  getSystemCryptoHotWallets(
    request: stark_api_ultron_pb.GetSystemCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.GetSystemCryptoHotWalletsReply>;

  getSystemCryptoHotWallets(
    request: stark_api_ultron_pb.GetSystemCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.GetSystemCryptoHotWalletsReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.GetSystemCryptoHotWalletsReply>;

  getSystemCryptoHotWallets(
    request: stark_api_ultron_pb.GetSystemCryptoHotWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.GetSystemCryptoHotWalletsReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/GetSystemCryptoHotWallets',
        request,
        metadata || {},
        this.methodInfoGetSystemCryptoHotWallets,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/GetSystemCryptoHotWallets',
    request,
    metadata || {},
    this.methodInfoGetSystemCryptoHotWallets);
  }

  methodInfoLoadCryptoWallets = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.LoadCryptoWalletsReply,
    (request: stark_api_ultron_pb.LoadCryptoWalletsRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.LoadCryptoWalletsReply.deserializeBinary
  );

  loadCryptoWallets(
    request: stark_api_ultron_pb.LoadCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.LoadCryptoWalletsReply>;

  loadCryptoWallets(
    request: stark_api_ultron_pb.LoadCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.LoadCryptoWalletsReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.LoadCryptoWalletsReply>;

  loadCryptoWallets(
    request: stark_api_ultron_pb.LoadCryptoWalletsRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.LoadCryptoWalletsReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/LoadCryptoWallets',
        request,
        metadata || {},
        this.methodInfoLoadCryptoWallets,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/LoadCryptoWallets',
    request,
    metadata || {},
    this.methodInfoLoadCryptoWallets);
  }

  methodInfoUpdateAutoTransferCryptoWithdraw = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.UpdateAutoTransferCryptoWithdrawReply,
    (request: stark_api_ultron_pb.UpdateAutoTransferCryptoWithdrawRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.UpdateAutoTransferCryptoWithdrawReply.deserializeBinary
  );

  updateAutoTransferCryptoWithdraw(
    request: stark_api_ultron_pb.UpdateAutoTransferCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.UpdateAutoTransferCryptoWithdrawReply>;

  updateAutoTransferCryptoWithdraw(
    request: stark_api_ultron_pb.UpdateAutoTransferCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.UpdateAutoTransferCryptoWithdrawReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.UpdateAutoTransferCryptoWithdrawReply>;

  updateAutoTransferCryptoWithdraw(
    request: stark_api_ultron_pb.UpdateAutoTransferCryptoWithdrawRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.UpdateAutoTransferCryptoWithdrawReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/UpdateAutoTransferCryptoWithdraw',
        request,
        metadata || {},
        this.methodInfoUpdateAutoTransferCryptoWithdraw,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/UpdateAutoTransferCryptoWithdraw',
    request,
    metadata || {},
    this.methodInfoUpdateAutoTransferCryptoWithdraw);
  }

  methodInfoGetCryptoSettings = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.GetCryptoSettingsReply,
    (request: stark_api_ultron_pb.GetCryptoSettingsRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.GetCryptoSettingsReply.deserializeBinary
  );

  getCryptoSettings(
    request: stark_api_ultron_pb.GetCryptoSettingsRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.GetCryptoSettingsReply>;

  getCryptoSettings(
    request: stark_api_ultron_pb.GetCryptoSettingsRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.GetCryptoSettingsReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.GetCryptoSettingsReply>;

  getCryptoSettings(
    request: stark_api_ultron_pb.GetCryptoSettingsRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.GetCryptoSettingsReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/GetCryptoSettings',
        request,
        metadata || {},
        this.methodInfoGetCryptoSettings,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/GetCryptoSettings',
    request,
    metadata || {},
    this.methodInfoGetCryptoSettings);
  }

  methodInfoCallbackTransaction = new grpcWeb.AbstractClientBase.MethodInfo(
    stark_api_ultron_pb.CallbackTransactionReply,
    (request: stark_api_ultron_pb.CallbackTransactionRequest) => {
      return request.serializeBinary();
    },
    stark_api_ultron_pb.CallbackTransactionReply.deserializeBinary
  );

  callbackTransaction(
    request: stark_api_ultron_pb.CallbackTransactionRequest,
    metadata: grpcWeb.Metadata | null): Promise<stark_api_ultron_pb.CallbackTransactionReply>;

  callbackTransaction(
    request: stark_api_ultron_pb.CallbackTransactionRequest,
    metadata: grpcWeb.Metadata | null,
    callback: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.CallbackTransactionReply) => void): grpcWeb.ClientReadableStream<stark_api_ultron_pb.CallbackTransactionReply>;

  callbackTransaction(
    request: stark_api_ultron_pb.CallbackTransactionRequest,
    metadata: grpcWeb.Metadata | null,
    callback?: (err: grpcWeb.Error,
               response: stark_api_ultron_pb.CallbackTransactionReply) => void) {
    if (callback !== undefined) {
      return this.client_.rpcCall(
        this.hostname_ +
          '/mcuc.stark.ultron.Ultron/CallbackTransaction',
        request,
        metadata || {},
        this.methodInfoCallbackTransaction,
        callback);
    }
    return this.client_.unaryCall(
    this.hostname_ +
      '/mcuc.stark.ultron.Ultron/CallbackTransaction',
    request,
    metadata || {},
    this.methodInfoCallbackTransaction);
  }

}


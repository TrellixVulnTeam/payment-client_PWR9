(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
  typeof define === 'function' && define.amd ? define(['react'], factory) :
  (global = global || self, global.useForkRef = factory(global.React));
}(this, function (react) { 'use strict';

  /**
   * Credit to material-ui for this snippet
   */
  function setRef(ref, value) {
      if (typeof ref === "function") {
          ref(value);
      }
      else if (ref) {
          ref.current = value;
      }
  }
  function useForkRef(refA, refB) {
      /**
       * This will create a new function if the ref props change and are defined.
       * This means react will call the old forkRef with `null` and the new forkRef
       * with the ref. Cleanup naturally emerges from this behavior
       */
      return react.useMemo(function () {
          if (refA == null && refB == null) {
              return null;
          }
          return function (refValue) {
              setRef(refA, refValue);
              setRef(refB, refValue);
          };
      }, [refA, refB]);
  }

  return useForkRef;

}));
//# sourceMappingURL=index.js.map
